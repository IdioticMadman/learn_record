## Java相关知识

### Java平台的理解

* Java语言：面向对象（封装，继承，多态），泛型，lambda表达式
* Java基础类库：集合，IO/NIO，网络，多线程，安全
* JVM：屏蔽系统底层实现，write once，run anywhere
  * 解释执行，但是有JIT（Just In Time）和AOT（Ahead-of-Time Compilation）优化
  * ClassLoader机制（双亲委派机制）,加载过程大致有 加载、验证、链接、初始化
  * GC机制，GC垃圾回收器
* Java相关工具，编译器（javac），诊断和监控工具等

### Exception和Error的区别

本质上就是考察Java的异常处理机制。

* 理解Throwable，Exception和Error的设计和分类

  Exception和Error都是继承Throwable

  * Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相关处理。Exception又分为，可检查异常，和不检测异常。可检查异常，必要要在代码中显式的进行捕获处理，在编译期就会强制检查。不检查异常就是所谓的运行时异常（NPE，ArrayIndexOutOfBoundsException..），具体根据需要来判断是否需要捕获，并不会在编译期强制要求。
  * Error是指正常情况下，不大可能出现的情况。基本全部Error都会导致JVM处于非正常状态，不可以恢复状态。所以一般来说，Error不便于捕获，也不需要捕获。

  ![img](https://static001.geekbang.org/resource/image/ac/00/accba531a365e6ae39614ebfa3273900.png)想想，NoClassDefFoundError和ClassNotFoundException的区别。

* 理解Java语言中操作Throwable的元素。也就是了解try catch finally throw throws关键字，以及处理一些异常场景

  * 尽量不要捕获Exception通用的异常，捕获特定异常
  * 不要生吞异常，不要不抛出异常
  * 尽量使用日志打印异常，不要直接打印堆栈
  * Throw early, Catch late
  * 当函数有try catch语句块并在其中进行return时，注意finally的语句不会影响返回值。

### final，finally，finalize有什么不同

1. final

   * 将方法或者类声明为final，则可以明确告知别人，这些行为是不许修改的

   * 使用final修饰变量或者参数，可以清楚的避免意外赋值导致。同时，final变量产生了某种程度不可变的效果，可以用于保护只读数据，在并发编程中，有利于减少额外的同步开销

2. finally

   try catch语句块中的关键字。如果有finally语句块则必会执行，除了一些再try里面做了一些骚操作。列如：

   ```java
   try {
   	//do something
   	System.exit(1);
   }finally {
   	System.out.println(“Print from finally”);
   }
   ```

3. finalize

   不推荐实现finalize的方法。因为无法保证finalize什么时候被执行，执行是否符合预期。使用不当会影响性能，导致程序死锁，挂起等。

   finalize设计成被垃圾收集前调用。这就意味着实现了finalize方法的对象是一个"特殊公民"，JVM要对它进行额外处理。finalize本质上成为了快速回收的阻碍者，可能会导致你的对象经过多个垃圾收集周期才能被回收。

   从另外一个角度上看，我们要确保回收资源就是因为资源是有限的。垃圾收集时间的不可预测，可能极大加剧资源的占用。所以，资源用完即显示释放，或者利用资源池尽量重用

### 四大引用（强，弱，软，虚）

* 强引用

  最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还"活着"。垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将相应引用赋值为null，就是可以被垃圾收集的了。但是具体回收时机还是要看垃圾收集策略

* 软引用

  软引用，是一种相对强引用弱化一些的引用。可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存。当内存不足时清理掉，这样就保证了是用缓存的同时，不会耗尽内存。

* 弱引用

  弱引用并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这样就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时，对象还在，就使用它，否则重新实例化。

* 虚引用

  虚引用，也称作幻象引用。不能通过它访问对象。虚引用仅仅提供了一种确保被对象finalize以后，做某些事情的机制。如通常用来做所谓的Post-Mortem清理机制，监控对象的创建和销毁。



**对象可达状态流转分析**

  ![对象可达性状态流转](https://static001.geekbang.org/resource/image/36/b0/36d3c7b158eda9421ef32463cb4d4fb0.png)

* 强可达：当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，新建一个对象，那么创建它的线程就是强可达。
* 软可达：只能通过软引用才能访问到对象的状态
* 弱可达：无法通过强引用或者软引用访问。只能通过弱引用访问的状态。非常临近finalize状态的时机，当弱引用被清除的时候，就符合finalize的条件
* 幻象可达：没有强，软，弱引用关联，并且finalize过了，只有弱引用指向这个对象
* 不可达：意味着对象可以被清楚了

除了幻象引用，如果对象还没有被销毁，都可以通过get方法获取原有对象。这意味着，利用软引用和弱引用，我们可以访问到的对象，重新指向强引用，也就是认为的改变了对象的可达性状态。看上面的图，有双向的。



**引用队列**

我们在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM会在特定时机(可以简单的理解为被回收的时候)将引用enqueue到队列中。然后可以从队列里面获取引用(remove方法在这里实际是有获取的意思)。尤其是幻象引用，get方法只返回null，如果再不指定引用队列，基本就没有意义了





### String,StringBuilder,StringBuffer

这三者加起来，就是Java是怎么处理字符串的封装类。一般来说，应用的大多数数据也就是字符串。

1. 字符串设计，String被设计的就是final，Immutable的类。原生的保证了基础线程安全。StringBuffer，通过把各种修改数据的方法都加上synchronized关键字，保证在使用字符串拼接的时候，保证线程安全。当然也提供了StringBuilder，在不是并发的情况下，提供字符串拼接的功能
2. 字符串缓存，Java6之后提供了intern()方法。

