[toc]

# 插件化相关点

## 概述

插件化其实就是安卓上面动态化的体现，要实现这个插件化主要会涉及到以下几点内容。

* Java反射api，以及动态代理模式的使用。是插件化的最基本的工具。
* App的启动流程，ActivityThread，LoadedApk，android四大组件运行的基本原理等。以便于我们能找到相关的hook点，欺骗系统进行四大组件的加载。
* 插件apk的资源加载，主要是涉及到AssetManager和Resource对资源的一个加载。以及如何处理资源id冲突的问题
* So包的动态化方案，用以加载插件中的so包
* 开发过程中到的代码混淆，以及maven重复库的依赖去除

## 反射

### 获取对象

根据类全限定名获取一个对象

```java
//多个参数
public static Object createObject(Class clazz, Class[] pareTypes, Object[] pareValues) {
    try {
        Constructor ctor = clazz.getDeclaredConstructor(pareTypes);
        ctor.setAccessible(true);
        return ctor.newInstance(pareValues);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
```

### 获取属性（Field or Method）

获取一个类所有公有或私有、静态或实例的字段，方法，属性

```java
//静态对象，obj传null
public static Object getFieldObject(Class clazz, Object obj, String fieldName) {
    try {
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(obj);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
//静态对象，obj传null
public static void setFieldObject(Class clazz, Object obj, String fieldName, Object fieldValue) {
    try {
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, fieldValue);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
public static Object invokeInstanceMethod(Object obj, String methodName, Class[] pareTypes, Object[] pareValues) {
    if (obj == null)
        return null;

    try {
        Method method = obj.getClass().getDeclaredMethod(methodName, pareTypes); //在指定类中获取指定的方法
        method.setAccessible(true);
        return method.invoke(obj, pareValues);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
public static Object invokeStaticMethod(Class clazz, String method_name, Class[] pareTypes, Object[] pareValues) {
    try {
        Method method = clazz.getDeclaredMethod(method_name, pareTypes);
        method.setAccessible(true);
        return method.invoke(null, pareValues);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
```

### 对泛型类的反射

![](https://tva1.sinaimg.cn/large/008eGmZEgy1govvq88jbqj30mt0800tk.jpg)

* ParameterizedType  参数化类型

  ```java
  public class ParameterizedTypeTest {
      private HashMap<String, Object> map;
      private HashSet<String> set;
      private List<String> list;
      private Class<?> clz;
  
      //不是ParameterizedType
      private Integer i;
      private String str;
  
      public static void main(String[] args) throws NoSuchFieldException {
          Field[] fields = ParameterizedTypeTest.class.getDeclaredFields();
          for (Field f : fields) {
              //打印是否是ParameterizedType类型
              System.out.println("FieldName:  " + f.getName() + " instanceof ParameterizedType is : " +
                      (f.getGenericType() instanceof ParameterizedType));
          }
          //取map这个类型中的实际参数类型的数组
          getParameterizedTypeWithName("map");
      }
  
      private static void getParameterizedTypeWithName(String name) throws NoSuchFieldException {
          Field f;
          //利用反射得到TestParameterizedTypeBean类中的所有变量
          f = ParameterizedTypeTest.class.getDeclaredField(name);
          f.setAccessible(true);
          Type type = f.getGenericType();
          if (type instanceof ParameterizedType) {
              for (Type param : ((ParameterizedType) type).getActualTypeArguments()) {
                  //打印实际参数类型
                  System.out.println("---type actualType---" + param.toString());
              }
              //打印所在的父类的类型
              System.out.println("---type ownerType0---" + ((ParameterizedType) type).getOwnerType());
              //打印其本身的类型
              System.out.println("---type rawType---" + ((ParameterizedType) type).getRawType());
          }
      }
  }
  ```

* GenericArrayType 泛型数组类型

  ```java
  public class TestGenericArrayType<T> {
  
      //泛型数组类型
      private T[] value;
      private List<String>[] list;
  
      //不是泛型数组类型
      private List<String> singleList;
      private T singleValue;
  
      public static void main(String[] args) {
          Field[] fields = TestGenericArrayType.class.getDeclaredFields();
          for (Field field : fields) {
              field.setAccessible(true);
              //输出当前变量是否为GenericArrayType类型
              System.out.println("Field: "
                      + field.getName()
                      + "; instanceof GenericArrayType"
                      + ": "
                      + (field.getGenericType() instanceof GenericArrayType));
              if (field.getGenericType() instanceof GenericArrayType) {
                  //如果是GenericArrayType，则输出当前泛型类型
                  System.out.println("Field: "
                          + field.getName()
                          + "; getGenericComponentType()"
                          + ": "
                          + (((GenericArrayType) field.getGenericType()).getGenericComponentType()));
              }
          }
      }
  }
  ```

* WildcardType 通配符泛型

  ```java
  public class TestWildcardType {
  
      public void testWildcardType(List<? extends OutputStream> numberList, List<? super InputStream> upperList,
                                   List<Integer> list, InputStream inputStream) {
      }
  
      public static void main(String[] args) {
          //获取TestWildcardType类的所有方法(本例中即 testWildcardType 方法)
          Method[] methods = TestWildcardType.class.getDeclaredMethods();
          for (Method method : methods) {
              //获取方法的所有参数类型
              Type[] types = method.getGenericParameterTypes();
              for (Type paramsType : types) {
                  System.out.println("type: " + paramsType.toString());
                  //如果不是参数化类型则直接continue，执行下一个循环条件
                  if (!(paramsType instanceof ParameterizedType)) {
                      continue;
                  }
                  //将当前类型强转为参数化类型并获取其实际参数类型(即含有通配符的泛型类型)
                  Type type = ((ParameterizedType) paramsType).getActualTypeArguments()[0];
                  //输出其是否为通配符类型
                  System.out.println("type instanceof WildcardType : " + (type instanceof WildcardType));
                  if (type instanceof WildcardType) {
                      int lowIndex = ((WildcardType) type).getLowerBounds().length - 1;
                      int upperIndex = ((WildcardType) type).getUpperBounds().length - 1;
                      //输出上边界与下边界
                      System.out.println("getLowerBounds(): "
                              +
                              (lowIndex >= 0 ? ((WildcardType) type).getLowerBounds()[lowIndex] : "String ")
                              + "; getUpperBounds(): "
                              +
                              (upperIndex >= 0 ? ((WildcardType) type).getUpperBounds()[upperIndex] : "Object"));
                  }
              }
          }
      }
  }
  ```

* TypeVariable 类型变量

  ```java
  public class TypeVariableTest<K extends Number, T> {
       //K有指定了上边界Number
       K key;
       //T没有指定上边界，其默认上边界为Object
       T value;
  
       public static void main(String[] args){
           Type[] types = TypeVariableTest.class.getTypeParameters();
           for (Type type : types){
               TypeVariable t = (TypeVariable) type;
               int index = t.getBounds().length - 1;
               //输出上边界
               System.out.println("--getBounds()-- " + t.getBounds()[index]);
               //输出名称
               System.out.println("--getName()--" + t.getName());
               //输出所在的类的类型
               System.out.println("--getGenericDeclaration()--" +  t.getGenericDeclaration());
           }
       }
   }
  ```

*ps: Java泛型实际上在编译的时候是会被擦除的，反射获取到的类型实际上是存在class的signature属性表中[Class文件属性表](https://blog.csdn.net/en_joker/article/details/79868865)*

### android P上面 hide api反射突破

hidden api被限制的实现原理 http://gityuan.com/2019/01/26/hidden_api/ 。主要是根据以下策略进行拦截

![hidden-api-exp](https://tva1.sinaimg.cn/large/008eGmZEgy1govvq1tlsyj30qo0f0dgi.jpg)

主要情况：

- 当EnforcementPolicy强制不限制的情况，即根据上表策略
- 当类加载器是Boot classloader的情况
- 当caller是平台dex文件的情况
- 当处于debuggable调试模式且caller已被标记可信任的情况
- 当GetHiddenApiExemptions为豁免情况

突破方案：

- 修改ART的EnforcementPolicy，也就是Runtime中的成员变量hidden_api_policy_，可以基于地址偏移找到相应的成员
- 修改hide API豁免变量，也就是Runtime中的成员变量hidden_api_exemptions_，可以 [VMRuntime.setHiddenApiExemptions](https://cs.android.com/android/platform/superproject/+/android-9.0.0_r1:libcore/libart/src/main/java/dalvik/system/VMRuntime.java;l=278) Java方法设置
- 修改classLoader为BootClassLoader

突破这个限制参考这个 https://github.com/tiann/FreeReflection。此方案是参考上述第二个方案实现的。解析文章：[another-free-reflection-above-android-p](http://weishu.me/2019/03/16/another-free-reflection-above-android-p/)

1. 借助系统的类去反射你想要反射的方法（借用caller是平台dex文件）

   ```java
   Method metaGetDeclaredMethod =
           Class.class.getDeclaredMethod("getDeclardMethod"); // 公开API，无问题
   Method hiddenMethod = metaGetDeclaredMethod.invoke(hiddenClass,
           "hiddenMethod", "hiddenMethod参数列表"); // 系统类通过反射使用隐藏 API，检查直接通过。
   hiddenMethod.invoke() // 正确找到 Method 直接反射调用
   ```

2. 获取VMRuntime实例，以及setHiddenApiExemptions的method

   ```java
   if (SDK_INT >= Build.VERSION_CODES.P) {
       try {
           Method forName = Class.class.getDeclaredMethod("forName", String.class);
           Method getDeclaredMethod = Class.class.getDeclaredMethod("getDeclaredMethod", String.class, Class[].class);
   
           Class<?> vmRuntimeClass = (Class<?>) forName.invoke(null, "dalvik.system.VMRuntime");
           Method getRuntime = (Method) getDeclaredMethod.invoke(vmRuntimeClass, "getRuntime", null);
         	//保存 setHiddenApiExemptions method
           setHiddenApiExemptions = (Method) getDeclaredMethod.invoke(vmRuntimeClass, "setHiddenApiExemptions", new Class[]{String[].class});
         	//保存 VmRuntime实例
           sVmRuntime = getRuntime.invoke(null);
       } catch (Throwable e) {
           Log.w(TAG, "reflect bootstrap failed:", e);
       }
   }
   ```

3. 使用setHiddenApiExemptions设置通过hide注解的方法签名，L开头匹配所有的方法了。

   ```java
   /**
    * Make all hidden API exempted.
    *
    * @return true if success.
    */
   public static boolean exemptAll() {
       return exempt(new String[]{"L"});
   }
   /**
    * make specific methods exempted from hidden API check.
    *
    * @param methods the method signature prefix, such as "Ldalvik/system", "Landroid" or even "L"
    * @return true if success
    */
   public static boolean exempt(String... methods) {
       if (sVmRuntime == null || setHiddenApiExemptions == null) {
           return false;
       }
       try {
           setHiddenApiExemptions.invoke(sVmRuntime, new Object[]{methods});
           return true;
       } catch (Throwable e) {
           return false;
       }
   }
   ```


## 动态代理的原理

一个简单的demo

```java
public interface HelloWorld {
    void sayHello(String name);
}
```

```java
public class HelloWorldImpl implements HelloWorld {
    @Override
    public void sayHello(String name) {
        System.out.println("Hello: " + name);
    }
}
```

```java
public class CustomInvocationHandler implements InvocationHandler {
    private final Object target;
    public CustomInvocationHandler(Object target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before invocation");
        Object ret = method.invoke(target, args);
        System.out.println("After invocation");
        return ret;
    }
}
```

```java
public class ProxyTest {
    public static void main(String[] args) {
        //设置保存生成出来的class类
        System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
        //实际上最后是通过 ProxyGenerator.generateProxyClass 来生成这个class文件（实现了对应接口的实现类）
        CustomInvocationHandler handler = new CustomInvocationHandler(new HelloWorldImpl());
        HelloWorld proxy = (HelloWorld) Proxy.newProxyInstance(
                ProxyTest.class.getClassLoader(),
                new Class[]{HelloWorld.class},
                handler);
        proxy.sayHello("Mikan");
    }
}
```

设置一下下面的这个选项，可以将动态生成class文件保存下来

```java
//设置保存生成出来的class类
System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
```

```java
public final class $Proxy0 extends Proxy implements HelloWorld {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;
 		static {
        m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
        m3 = Class.forName("com.company.proxy.HelloWorld").getMethod("sayHello", Class.forName("java.lang.String"));
        m2 = Class.forName("java.lang.Object").getMethod("toString");
        m0 = Class.forName("java.lang.Object").getMethod("hashCode");
    }

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
      	return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
    }

    public final void sayHello(String var1) throws  {
      	super.h.invoke(this, m3, new Object[]{var1});
    }

    public final String toString() throws  {
      	return (String)super.h.invoke(this, m2, (Object[])null);
    }

    public final int hashCode() throws  {
      	return (Integer)super.h.invoke(this, m0, (Object[])null);
    }
}
```

核心生成代理类的方法：

```java
private byte[] generateClassFile() {
    //第一步, 将所有的方法组装成ProxyMethod对象
    //首先为代理类生成toString, hashCode, equals等代理方法
    addProxyMethod(hashCodeMethod, Object.class);
    addProxyMethod(equalsMethod, Object.class);
    addProxyMethod(toStringMethod, Object.class);
    //遍历每一个接口的每一个方法, 并且为其生成ProxyMethod对象
    for (int i = 0; i < interfaces.length; i++) {
        Method[] methods = interfaces[i].getMethods();
        for (int j = 0; j < methods.length; j++) {
            addProxyMethod(methods[j], interfaces[i]);
        }
    }
    //对于具有相同签名的代理方法, 检验方法的返回值是否兼容
    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {
        checkReturnTypes(sigmethods);
    }
    
    //第二步, 组装要生成的class文件的所有的字段信息和方法信息
    try {
        //添加构造器方法
        methods.add(generateConstructor());
        //遍历缓存中的代理方法
        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {
            for (ProxyMethod pm : sigmethods) {
                //添加代理类的静态字段, 例如:private static Method m1;
                fields.add(new FieldInfo(pm.methodFieldName,
                        "Ljava/lang/reflect/Method;", ACC_PRIVATE | ACC_STATIC));
                //添加代理类的代理方法
                methods.add(pm.generateMethod());
            }
        }
        //添加代理类的静态字段初始化方法
        methods.add(generateStaticInitializer());
    } catch (IOException e) {
        throw new InternalError("unexpected I/O Exception");
    }
    
    //验证方法和字段集合不能大于65535
    if (methods.size() > 65535) {
        throw new IllegalArgumentException("method limit exceeded");
    }
    if (fields.size() > 65535) {
        throw new IllegalArgumentException("field limit exceeded");
    }
 
    //第三步, 写入最终的class文件
    //验证常量池中存在代理类的全限定名
    cp.getClass(dotToSlash(className));
    //验证常量池中存在代理类父类的全限定名, 父类名为:"java/lang/reflect/Proxy"
    cp.getClass(superclassName);
    //验证常量池存在代理类接口的全限定名
    for (int i = 0; i < interfaces.length; i++) {
        cp.getClass(dotToSlash(interfaces[i].getName()));
    }
    //接下来要开始写入文件了,设置常量池只读
    cp.setReadOnly();
    
    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    DataOutputStream dout = new DataOutputStream(bout);
    try {
        //1.写入魔数
        dout.writeInt(0xCAFEBABE);
        //2.写入次版本号
        dout.writeShort(CLASSFILE_MINOR_VERSION);
        //3.写入主版本号
        dout.writeShort(CLASSFILE_MAJOR_VERSION);
        //4.写入常量池
        cp.write(dout);
        //5.写入访问修饰符
        dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);
        //6.写入类索引
        dout.writeShort(cp.getClass(dotToSlash(className)));
        //7.写入父类索引, 生成的代理类都继承自Proxy
        dout.writeShort(cp.getClass(superclassName));
        //8.写入接口计数值
        dout.writeShort(interfaces.length);
        //9.写入接口集合
        for (int i = 0; i < interfaces.length; i++) {
            dout.writeShort(cp.getClass(dotToSlash(interfaces[i].getName())));
        }
        //10.写入字段计数值
        dout.writeShort(fields.size());
        //11.写入字段集合 
        for (FieldInfo f : fields) {
            f.write(dout);
        }
        //12.写入方法计数值
        dout.writeShort(methods.size());
        //13.写入方法集合
        for (MethodInfo m : methods) {
            m.write(dout);
        }
        //14.写入属性计数值, 代理类class文件没有属性所以为0
        dout.writeShort(0);
    } catch (IOException e) {
        throw new InternalError("unexpected I/O Exception");
    }
    //转换成二进制数组输出
    return bout.toByteArray();
}
```
*带注释源码：[ProxyGenerator](http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java)。class文件格式：[Class文件格式](http://gityuan.com/2015/10/18/jvm-class-instruction/#22-classfile%E7%BB%93%E6%9E%84)*

## HookPMS的简单流程

[android.app.ActivityThread](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:frameworks/base/core/java/android/app/ActivityThread.java;l=203)

[android.content.pm.IPackageManager](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:out/soong/.intermediates/frameworks/base/framework-minus-apex/android_common/xref31/srcjars.xref/android/content/pm/IPackageManager.java)

欺骗pms，说现在用到的这个activity是已经注册在manifest文件中的了

1. 找到ActivityThread中sPackageManager，造一个代理对象替换掉
2. 需要设置一下ContextImpl中的mPackageManager

```java
public static void hookPackageManager(Context context) {
    try {
        Object oriPm = RefInvoke.getFieldObject("android.app.ActivityThread", null,
                                                "sPackageManager");
        //做代理
        Class<?> ipmclz = Class.forName("android.content.pm.IPackageManager");
        Object proxyPm = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                                                new Class<?>[]{ipmclz}, new PMHandler(oriPm));
        //替换掉ActivityThread中的
        RefInvoke.setFieldObject("android.app.ActivityThread", null,
                                 "sPackageManager",
                                 proxyPm);
        //给context里面设置一下为空，如果为空的话，会去ActivityThread中获取
        RefInvoke.setFieldObject("android.app.ContextImpl", context, "mPackageManager", null);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
        throw new RuntimeException("hook packageManager failed", e);
    }
}

static class PMHandler implements InvocationHandler {

    private final Object rawPm;

    public PMHandler(Object rawPm) {
        this.rawPm = rawPm;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Log.d(TAG, " method (" + method.getName() + ") is hooked");
        return method.invoke(rawPm, args);
    }
}
```

## Activity插件化

![activity启动流程](https://tva1.sinaimg.cn/large/008eGmZEgy1govvqganvzj321q0te0v1.jpg)

### HookAMS的点

[android.app.ActivityManagerNative](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:frameworks/base/core/java/android/app/ActivityManagerNative.java;l=3047)

[android.util.Singleton](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:frameworks/base/core/java/android/util/Singleton.java;l=26)

[android.app.IActivityManager](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:out/soong/.intermediates/frameworks/base/framework-minus-apex/android_common/xref31/srcjars.xref/android/app/IActivityManager.java)

主要是用来欺骗ams，告诉它启动的四大组件是已经在manifest注册过了的，hook步骤主要是一下几点

1. 获取ActivityManagerNative中的gDefault属性
2. 获取Singleton的mInstance属性
3. 动态代理掉mInstance，设置回到单例中

这样我们就代理上了amn了，后续有什么操作可以在handler中进行了。

```java
public static void hookActivityManager() {
    try {
        //获取AMN的gDefault单例gDefault，gDefault是静态的
        Object gDefault = RefInvoke.getStaticFieldObject("android.app.ActivityManagerNative", "gDefault");
        //获取单例包装类里面的对象
        Object oriAm = RefInvoke.getFieldObject("android.util.Singleton", gDefault, "mInstance");
        //动态代理
        Class<?> iam = Class.forName("android.app.IActivityManager");
        Object amnProxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{iam}, new AMNHandler(oriAm));
        //设置代理对象到单例中
        RefInvoke.setFieldObject("android.util.Singleton", gDefault, "mInstance", amnProxy);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
        throw new RuntimeException("hook activityManager failed", e);
    }
}

static class AMNHandler implements InvocationHandler {

    private final Object rawAmn;

    public AMNHandler(Object rawAmn) {
        this.rawAmn = rawAmn;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      	//做自己想做的事情
        Log.d(TAG, " method (" + method.getName() + ") is hooked");
        return method.invoke(rawAmn, args);
    }
}
```

### 简单demo

如下，启动TargetActivity未申明在manifest中，在manifest文件中的是SubActivity

```xml
<activity android:name=".SubActivity" />
```

```java
 public void startTarget(View view) {
     startActivity(new Intent(this, TargetActivity.class));
 }
```

1. hook AMN启动已经配置在manifest的activity，即上面AMNHandler中需要处理startActivity方法，替换成申明在manifest里面的activity来欺骗AMS

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Log.d(TAG, " method (" + method.getName() + ") is hooked");
    if (method.getName().equals("startActivity")) {
        Intent oriIntent = null;
        int intentIndex = -1;
        //找出originIntent
        for (int i = 0; i < args.length; i++) {
            if (args[i] instanceof Intent) {
                intentIndex = i;
                oriIntent = (Intent) args[i];
                break;
            }
        }
        if (oriIntent != null) {
            //替换原始Intent
            Intent curIntent = new Intent();
            curIntent.putExtra(EXTRA_ORI_INTENT, oriIntent);
            curIntent.setComponent(new ComponentName(
                oriIntent.getComponent().getPackageName(),
                SubActivity.class.getName()));
            args[intentIndex] = curIntent;
            Log.d(TAG, "handleLaunchActivity: 把原始Intent进行替换");
        }
    }
    return method.invoke(rawAmn, args);
}
```

2. hook ActivityThread中的H类的handleMessage，处理一下handleLaunchActivity，还原成原始的intent，启动目标activity

```java
public static void hookHandlerCreateActivity() {
    Object currentActivityThread = RefInvoke.getFieldObject("android.app.ActivityThread", null,
        "sCurrentActivityThread");
    Handler handler = (Handler) RefInvoke.getFieldObject(currentActivityThread, "mH");
    //设置给handler
    RefInvoke.setFieldObject(Handler.class, handler, "mCallback", new ActivityThreadHandlerCallback(handler));
}

static class ActivityThreadHandlerCallback implements Handler.Callback {

    private static final String TAG = "ActivityThreadHandler";
    private final Handler oriHandle;

    ActivityThreadHandlerCallback(Handler oriHandle) {
        this.oriHandle = oriHandle;
    }

    @Override
    public boolean handleMessage(Message msg) {
        if (msg.what == 100) {
            // ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100
            handleLaunchActivity(msg);
        }
        oriHandle.handleMessage(msg);
        return true;
    }

    /**
     * 还原handler
     *
     * @param msg handler的msg
     */
    private void handleLaunchActivity(Message msg) {
        Object obj = msg.obj;
        Intent intent = (Intent) RefInvoke.getFieldObject(obj, "intent");
        Intent oriIntent = intent.getParcelableExtra(EXTRA_ORI_INTENT);
        if (oriIntent != null) {
            RefInvoke.setFieldObject(obj, "intent", oriIntent);
            Log.d(TAG, "handleLaunchActivity: 替换成原始Intent");
        }
    }
}
```

此种情况只是为了骗过ams启动一个未注册在manifest的Activity类，接下来分析启动插件中的Activity。

## 获取插件中的类

[dalvik.system.BaseDexClassLoader](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java)，[dalvik.system.DexClassLoader](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java)，[dalvik.system.PathClassLoader](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java)

[dalvik.system.DexPathList](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:libcore/dalvik/src/main/java/dalvik/system/DexPathList.java)

[dalvik.system.DexFile](https://cs.android.com/android/platform/superproject/+/android-7.1.2_r36:libcore/dalvik/src/main/java/dalvik/system/DexFile.java)

#### 为每个插件都创建一个ClassLoader

这个方案的思路点关键在`android.app.ActivityThread#performLaunchActivity`时使用`ActivityClientRecord`的`LoadedApk packageInfo`的classLoader进行加载的class

```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
  ...
    Activity activity = null;
    try {
        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
      	...
    }
}
```

这个packageInfo是在`android.app.ActivityThread#getPackageInfo(android.content.pm.ApplicationInfo, CompatibilityInfo, java.lang.ClassLoader, boolean, boolean, boolean)`中可以从缓存中命中

```java
private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
        boolean registerPackage) {
        WeakReference<LoadedApk> ref;
        if (differentUser) {
            // Caching not supported across users
            ref = null;
        } else if (includeCode) {
            ref = mPackages.get(aInfo.packageName);
        } else {
            ref = mResourcePackages.get(aInfo.packageName);
        }
```

所以就有以下hook的代码：

1. 获取mPackages对象
2. 准备ApplicationInfo和compatibilityInfo
3. 准备好的两个参数扔给getPackageInfoNoCheck获取loadedApk
4. 构造自定义的classLoader扔给loadedApk
5. 塞回mPackages

```java
public static void hookLoadedApkInActivityThread(File apkFile) {
    // 先获取到当前的ActivityThread对象
    Object currentActivityThread = RefInvoke.invokeStaticMethod("android.app.ActivityThread", "currentActivityThread");
    // 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息
    Map mPackages = (Map) RefInvoke.getFieldObject(currentActivityThread, "mPackages");
    // 准备两个参数
    // android.content.res.CompatibilityInfo
    Object defaultCompatibilityInfo = RefInvoke.getStaticFieldObject("android.content.res.CompatibilityInfo", "DEFAULT_COMPATIBILITY_INFO");
    //从apk中取得ApplicationInfo信息
    ApplicationInfo applicationInfo = generateApplicationInfo(apkFile);
    //调用ActivityThread的getPackageInfoNoCheck方法loadedApk，得到，上面两个数据都是用来做参数的
    Class[] p1 = {ApplicationInfo.class, Class.forName("android.content.res.CompatibilityInfo")};
    Object[] v1 = {applicationInfo, defaultCompatibilityInfo};
    Object loadedApk = RefInvoke.invokeInstanceMethod(currentActivityThread, "getPackageInfoNoCheck", p1, v1);
    //为插件造一个新的ClassLoader
    String odexPath = Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();
    String libDir = Utils.getPluginLibDir(applicationInfo.packageName).getPath();
    ClassLoader classLoader = new CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());
    RefInvoke.setFieldObject(loadedApk, "mClassLoader", classLoader);
    //把插件LoadedApk对象放入缓存
    WeakReference weakReference = new WeakReference(loadedApk);
    mPackages.put(applicationInfo.packageName, weakReference);
}
```

准备ApplicationInfo有点复杂，且版本变化较大，单独抽出来

1. 先根据`android.content.pm.PackageParser#parsePackage`生成`android.content.pm.PackageParser.Package`
2. 在用`android.content.pm.PackageParser#generateApplicationInfo(android.content.pm.PackageParser.Package, int, android.content.pm.PackageUserState)` 创建ApplicationInfo

```java
/**
 * 这个方法的最终目的是调用
 * android.content.pm.PackageParser#generateActivityInfo(android.content.pm.PackageParser.Activity, int, android.content.pm.PackageUserState, int)
 */
public static ApplicationInfo generateApplicationInfo(File apkFile){

    // 找出需要反射的核心类: android.content.pm.PackageParser
    Class<?> packageParserClass = Class.forName("android.content.pm.PackageParser");
    Class<?> packageParser$PackageClass = Class.forName("android.content.pm.PackageParser$Package");
    Class<?> packageUserStateClass = Class.forName("android.content.pm.PackageUserState");

    // 首先, 我们得创建出一个Package对象出来供这个方法调用
    // 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到
    // 创建出一个PackageParser对象供使用
    Object packageParser = packageParserClass.newInstance();

    // 调用 PackageParser.parsePackage 解析apk的信息
    // 实际上是一个 android.content.pm.PackageParser.Package 对象
    Class[] p1 = {File.class, int.class};
    Object[] v1 = {apkFile, 0};
    Object packageObj = RefInvoke.invokeInstanceMethod(packageParser, "parsePackage", p1, v1);

    // 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可
    Object defaultPackageUserState = packageUserStateClass.newInstance();

    // 万事具备!!!!!!!!!!!!!!
    Class[] p2 = {packageParser$PackageClass, int.class, packageUserStateClass};
    Object[] v2 = {packageObj, 0, defaultPackageUserState};
    ApplicationInfo applicationInfo = (ApplicationInfo)RefInvoke.invokeInstanceMethod(packageParser, "generateApplicationInfo", p2, v2);
    String apkPath = apkFile.getPath();
    applicationInfo.sourceDir = apkPath;
    applicationInfo.publicSourceDir = apkPath;

    return applicationInfo;
}
```

*ps: PathClassLoader和DexClassLoader，都是继承自DexClassloader。但是PathClassLoader少一个参数（optimizedDirectory）。所以DexClassLoader一般用来加载自定义apk路径的，PathClassLoader一般是用来加载系统默认位置的apk所以这里CustomClassLoader，是继承DexClassLoader* 

但是这种方案比较复杂，要反射一堆类型的对象，还需要适配各种android版本，不好使

#### 将dex合并到宿主的PathClassLoader中

1. 根据宿主的classLoader获取pathList字段
2. 从DexPathList中获取dexElements字段，这个是一个数组
3. 根据插件的apkFile，反射出一个Element类型
4. 造一个新的数组加上插件apkFile中的dex，塞回去

```java
/**
 * 将插件apk文件的dex塞到我们plugin的pathClassLoader的dexPathList中
 * 这样就可以直接找到插件中的class文件了
 *
 * @param cl      当前的classLoader
 * @param apkFile 插件apk文件
 * @param optFile 插件dex优化的目录
 */
public static void loadPluginDex(ClassLoader cl, File apkFile, File optFile) throws IOException {
    //获取BaseDexClassLoader中的DexPathList
    Object pathList = RefInvoke.getFieldObject(cl.getClass().getSuperclass(), cl, "pathList");
    //获取DexPathList中的dexElements
    Object[] dexElements = (Object[]) RefInvoke.getFieldObject(pathList.getClass(), pathList, "dexElements");
    //获取Element的类型
    Class<?> elementClass = dexElements.getClass().getComponentType();
    //创建一个数组长度+1 替换原来的Elements数据
    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + 1);
    //构造插件Element
    Class<?>[] paramClass = {File.class, boolean.class, File.class, DexFile.class};
    Object[] values = {apkFile, false, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optFile.getAbsolutePath(), 0)};
    Object newElement = RefInvoke.createObject(elementClass, paramClass, values);
    //将所有的elements拷贝到新的数组中去
    Object[] toAddElement = new Object[]{newElement};
    System.arraycopy(dexElements, 0, newElements, 0, dexElements.length);
    System.arraycopy(toAddElement, 0, newElements, dexElements.length, toAddElement.length);
    //设置回dexPathList中
    RefInvoke.setFieldObject(pathList, "dexElements", newElements);
}
```

Small中也是核心原理也是采用后面这种方案。且做了一些版本的兼容，主要是出现在构建DexFile的方法

## 获取插件中的资源

### 资源的获取

android资源获取的过程是通过AssetManager和Resource类完成的。Resource根据资源ID来查找资源文件的名称，AssetManager通过资源文件名称来找具体的资源。

获取插件中的资源就要用到AssetManager调用addAssetPath(String path)去添加一个新的path。类似于换肤原理，写在基类中，生成一个可以加载apk的AssetManager，生成一个新的Resource对象，重写掉这些获取资源。就可以相当于换肤了。这里只是简单demo，这样写会导致宿主的资源加载不到。

```java
//在activity的attachBaseContext中调用一下
protected void loadPluginResource(String apkPath) {
    try {
        AssetManager assetManager = AssetManager.class.newInstance();
        RefInvoke.invokeInstanceMethod(assetManager, "addAssetPath", String.class, apkPath);
        Resources resources = super.getResources();
        mAssetManager = assetManager;
        mResources = new Resources(assetManager, resources.getDisplayMetrics(), resources.getConfiguration());
        mTheme = mResources.newTheme();
        mTheme.setTo(super.getTheme());
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
}

@Override
public AssetManager getAssets() {
    return mAssetManager == null ? super.getAssets() : mAssetManager;
}

@Override
public Resources getResources() {
    return mResources == null ? super.getResources() : mResources;
}

@Override
public Resources.Theme getTheme() {
    return mTheme == null ? super.getTheme() : mTheme;
}
```

Small中插件资源管理是维护了全局的一个assetManager，其中保存了所有的apkPath。在基类重写了getResource方法，在其中判断Resource中的assetManager是否为全局这个。否则替换成全局这个

```java
@Override
public Resources getResources() {
  Resources resources = super.getResources();
  AssetManager smallAssets = Small.getAssetManager();
  if (null != smallAssets && resources.getAssets() != smallAssets) {
    MLog.error(getClass().getSimpleName() + " " + hashCode(),
               "current activity Assets and Small Assets not equal");
    //更新resource的assetManager为Small中的AssetManager
    ReflectAccelerator.updateActivityResource(this, resources);
  }
  return resources;
}
```

### 资源Id冲突怎么解决

目前有两种方案

* gradle插件处理。大致原理是hookAapt，解压生成的resource.ap_，解析R.txt，根据public_resource.txt（上层插件构建产物）过滤后（需要删除这种重复的资源），根据传入的`packageId`重新生成resource.arsc，重新输出R.txt，并根据最新的R.txt，重新生成R.java文件。

* 修改aapt支持传入pp字段，不过最新的aapt2已经可以支持了。但是这样会有很多冗余的存在

  ![image-20210324172735208](https://tva1.sinaimg.cn/large/008eGmZEgy1govvqot8ejj30ny05z0u6.jpg)

  ```groovy
  android {
      aaptOptions {
        	//添加构键参数
          additionalParameters  "--allow-reserved-package-id", "--package-id"," 0x60"
      }
  }
  ```

  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1govvqte6o6j314g0rawj2.jpg" style="zoom:35%;" /><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1govvqy6o1cj30u00vpdn7.jpg" style="zoom:43%;" />

Small插件化是采用的第一种。还有一个小问题需要解决，依赖同一份library的插件和宿主，要生成一样资源id。同样是给aapt设置参数，在构建构建

![image-20210326105829099](https://tva1.sinaimg.cn/large/008eGmZEgy1gox4gigpvej30ml03ft9q.jpg)

ps：这里有一个小知识点，aapt和aapt2的区别。[AAPT2产物逆向](https://booster.johnsonlee.io/architecture/aapt2-output-reversing.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%86%E5%90%91-aapt2-%E4%BA%A7%E7%89%A9)

## 插件so包加载

有两种解决方案

* System.loadLibrary()。此方案呢，在预加载这个插件的时候，反射当前的ClassLoader将需要加载的so文件的路径塞到`libraryPathElements`中。

  ```java
  public static void expandNativeLibraryDirectories(ClassLoader classLoader,
                                                    List<File> libPaths, boolean push) {
      if (sPathClassLoader_libraryPathElements_field == null) {
          sPathClassLoader_libraryPathElements_field = getDeclaredField(
                  classLoader.getClass(), "libraryPathElements");
      }
      List<String> paths = getValue(sPathClassLoader_libraryPathElements_field, classLoader);
      if (paths == null) {
          return;
      }
      for (File libPath : libPaths) {
          if (push) {
              paths.add(0, libPath.getAbsolutePath() + File.separator);
          } else {
              paths.add(libPath.getAbsolutePath() + File.separator);
          }
      }
  }
  ```

* System.load() 这个就传入一个绝对路径。自己插件管理so包的位置了

两种方式最终都是调用到了

- 通过dlopen打开动态共享库;
- 通过dlsym获取JNI_OnLoad符号所对应的方法；
- 调用该加载库中的JNI_OnLoad()方法。

*具体的加载流程参考：[loadLibrary](http://gityuan.com/2017/03/26/load_library/)*

## 插件的混淆

关键是在混淆的时候设置这个参数：

`-applymapping <mapping file>`

当宿主和插件依赖同一份library的时，插件构建出来后生成的mapping.txt需要给到宿主使用相同的规则进行混淆。

在small中由`com.yy.android.small.gradle.BundlePlugin` 会有一个`task smallAarPluginInfo` 回去收集当前插件的info信息，放在`small-artifacts`文件夹中

## 重复依赖库剔除

Android构建transform会依次对依赖的jar包做处理，最终由dexBuilder打包生成dex。small对依赖库的剔除，是注册一个剔除jar的transfrom，transform执行时将需要剔除的库jar包从transform的jarInputs集合中删除，只将需要打包的jar复制传递给下一个transform。

ps：最后两节细节参考已有文章[手Y插件化从构建到运行（构建）](https://git.yy.com/apps/yylive/Wiki/blob/master/Android/Small/build.md)

## 另类的插件化-静态代理

核心思想是利用一个注册在宿主的ProxyActivity来代理要被加载的Activity，来看下简单的demo

1. 申明接口给PluginActivity，便于在ProxyActivity调用

   ```java
   public interface IRemoteActivity {
       void onStart();
       void onRestart();
       void onActivityResult(int requestCode, int resultCode, Intent data);
       void onResume();
       void onPause();
       void onStop();
       void onDestroy();
       void onCreate(Bundle savedInstanceState);
       void setProxy(Activity proxyActivity, String dexPath);
   
       /**
        * 获取当前Activity的启动模式
        */
       int getLaunchMode();
   }
   ```

2. 实现一个PluginActivity的基础模版

   ```java
   public class BasePluginActivity extends Activity implements IRemoteActivity {
   
       private static final String TAG = "Client-BaseActivity";
   
       /**
        * 等同于mProxyActivity，可以当作Context来使用，会根据需要来决定是否指向this<br/>
        * 可以当作this来使用
        */
       protected Activity that;
       protected String dexPath;
   
   
       private int launchMode = LaunchMode.STANDARD;
   
       public void setLunchMode(int launchMode) {
           this.launchMode = launchMode;
       }
   
       @Override
       public int getLaunchMode() {
           return launchMode;
       }
   
   
       public void setProxy(Activity proxyActivity, String dexPath) {
           that = proxyActivity;
           this.dexPath = dexPath;
       }
   
       @Override
       public void onCreate(Bundle savedInstanceState) {
       }
   
       @Override
       public void onActivityResult(int requestCode, int resultCode, Intent data) {
       }
   
       @Override
       public void onStart() {
       }
   
       @Override
       public void onRestart() {
       }
   
       @Override
       public void onResume() {
       }
   
       @Override
       public void onPause() {
       }
   
       @Override
       public void onStop() {
       }
   
       @Override
       public void onDestroy() {
       }
   
       @Override
       public void setContentView(int layoutResID) {
           that.setContentView(layoutResID);
       }
   
       @Override
       public View findViewById(int id) {
           return that.findViewById(id);
       }
   
       @Override
       public void startActivity(Intent intent) {
           that.startActivity(intent);
       }
   
       @Override
       public void startActivityForResult(Intent intent, int requestCode) {
           that.startActivityForResult(intent, requestCode);
       }
   
       @Override
       public Resources getResources() {
           return that.getResources();
       }
   
       @Override
       public void finish() {
           that.finish();
       }
   
       @Override
       public Intent getIntent() {
           return that.getIntent();
       }
   }
   ```

3. ProxyActivity中根据要跳转的dexPath构建出对应的DexClassLoader，以及对应AssetManager给ProxyActivity使用

   ```java
   public class ProxyActivity extends BaseHostActivity {
   
       private static final String TAG = "ProxyActivity";
   
       private String mClass;
   
       private IRemoteActivity mRemoteActivity;
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           mDexPath = getIntent().getStringExtra(AppConstants.EXTRA_DEX_PATH);
           mClass = getIntent().getStringExtra(AppConstants.EXTRA_CLASS);
           Log.d(TAG, "onCreate: " + mDexPath + ", " + mClass);
           loadClassLoader();
           loadResources();
   
           launchTargetActivity(mClass);
       }
   
       void launchTargetActivity(final String className) {
           try {
               //反射出插件的Activity对象
               Class<?> localClass = dexClassLoader.loadClass(className);
               Constructor<?> localConstructor = localClass.getConstructor(new Class[]{});
               Object instance = localConstructor.newInstance(new Object[]{});
   
               mRemoteActivity = (IRemoteActivity) instance;
               CJBackStack.getInstance().launch(mRemoteActivity);
   
               //执行插件Activity的setProxy方法，建立双向引用
               mRemoteActivity.setProxy(this, mDexPath);
   
               Bundle bundle = new Bundle();
               mRemoteActivity.onCreate(bundle);
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   
       @Override
       protected void onActivityResult(int requestCode, int resultCode, Intent data) {
           Log.d(TAG, "onActivityResult resultCode=" + resultCode);
           mRemoteActivity.onActivityResult(requestCode, resultCode, data);
           super.onActivityResult(requestCode, resultCode, data);
       }
   
       @Override
       protected void onStart() {
           super.onStart();
           mRemoteActivity.onStart();
       }
   
       @Override
       protected void onRestart() {
           super.onRestart();
           mRemoteActivity.onRestart();
       }
   
       @Override
       protected void onResume() {
           super.onResume();
           mRemoteActivity.onResume();
       }
   
       @Override
       protected void onPause() {
           super.onPause();
           mRemoteActivity.onPause();
       }
   
       @Override
       protected void onStop() {
           super.onStop();
           mRemoteActivity.onStop();
       }
   
       @Override
       protected void onDestroy() {
           super.onDestroy();
           mRemoteActivity.onDestroy();
       }
   }
   ```

4. classLoader和assetManager的实现

   ```java
   public class BaseHostActivity extends Activity {
       private AssetManager mAssetManager;
       private Resources mResources;
       private Resources.Theme mTheme;
   
       protected String mDexPath;
       protected ClassLoader dexClassLoader;
   
       protected void loadClassLoader() {
           File dexOutputDir = this.getDir("dex", Context.MODE_PRIVATE);
           final String dexOutputPath = dexOutputDir.getAbsolutePath();
           dexClassLoader = new DexClassLoader(mDexPath,
                   dexOutputPath, null, getClassLoader());
       }
       protected void loadResources() {
           try {
               AssetManager assetManager = AssetManager.class.newInstance();
               Method addAssetPath = assetManager.getClass().getMethod("addAssetPath", String.class);
               addAssetPath.invoke(assetManager, mDexPath);
               mAssetManager = assetManager;
           } catch (Exception e) {
               e.printStackTrace();
           }
           Resources superRes = super.getResources();
           mResources = new Resources(mAssetManager, superRes.getDisplayMetrics(),
                   superRes.getConfiguration());
           mTheme = mResources.newTheme();
           mTheme.setTo(super.getTheme());
       }
   
       @Override
       public AssetManager getAssets() {
           return mAssetManager == null ? super.getAssets() : mAssetManager;
       }
   
       @Override
       public Resources getResources() {
           return mResources == null ? super.getResources() : mResources;
       }
   
       @Override
       public Resources.Theme getTheme() {
           return mTheme == null ? super.getTheme() : mTheme;
       }
   }
   ```

5. 需要一个集合来模拟activity的launchMode

   ```java
   public class CJBackStack {
       // 用链表来模拟一个Activity返回栈
       private static List<IRemoteActivity> atyStack = new ArrayList<IRemoteActivity>();
   
       private static CJBackStack instance = null;
   
       private CJBackStack() {
       }
   
       public static CJBackStack getInstance() {
           if(instance == null)
               instance = new CJBackStack();
   
           return instance;
       }
   
       /**
        * 根据launchMode去启动一个插件Activity
        * 首先将aty(插件)引用添加到链表尾,因为不管是何种launchmode,最终都是在栈顶.<br>
        * 从链表倒数第二个(未添加前的最后一个)开始遍历,若已有该aty的引用,则开始处理launchmode的情况。<br>
        * @param pluginAty
        *            要启动的插件Activity
        * @return 返回空表示成功添加一个插件Activity到返回栈栈顶而没有改变栈中其他元素
        */
       public void launch(IRemoteActivity pluginAty) {
           atyStack.add(pluginAty);
   
           if (atyStack.size() == 1)
               return;
   
           if(pluginAty.getLaunchMode() == LaunchMode.STANDARD)
               return;
   
           if(pluginAty.getLaunchMode() == LaunchMode.SINGLETOP) {
               //倒数第2个元素
               int index = atyStack.size() - 2;
               if (atyStack.get(index).getClass().getName().equals(
                       pluginAty.getClass().getName())) {
                   remove(atyStack.size() - 2);
               }
           }
   
           for (int i = atyStack.size() - 2; i >= 0; i--) {
               if (atyStack.get(i).getClass().getName().equals(pluginAty.getClass().getName())) {
                   switch (pluginAty.getLaunchMode()) {
                       case LaunchMode.SINGLETASK: // 栈唯一
                           // 这里由于每次remove(),atyStack.size()会随之减小,故省略for语句第三段
                           for (int j = i; j < atyStack.size() - 1;) {
                               remove(j);
                           }
                           break;
                       case LaunchMode.SINGLEINSTANCE:// 应用唯一
                           remove(i);
                           break;
                   }
               }
           }
       }
   
       private void remove(int index) {
           IRemoteActivity aty = atyStack.get(index);
           atyStack.remove(index);
           if (aty instanceof BasePluginActivity) {
               ((BasePluginActivity) aty).finish();
           }
       }
   
       /**
        * 从返回栈栈顶开始移除第一个出现的参数aty<br>
        * 此处用对象比较而不是clazz比较，防止在返回栈中有两个Activity而删错<br>
        * 减2的原因：不能是栈顶的那个aty
        *
        * @param aty
        */
       public void finish(IRemoteActivity aty) {
           for (int i = atyStack.size() - 2; i >= 0; i--) {
               if (aty.equals(atyStack.get(i))) {
                   remove(i);
               }
           }
       }
   }
   ```

   

### 标题

