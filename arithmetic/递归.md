递归，是一个『递』过去，『归』回来的过程。不要尝试用脑子去递归。层级一多就蒙圈了。

### 递归需要满足的三个条件

1. 一个问题可以分解成几个子问题
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

### 如何编写递归代码

关键在于**写出递推公式，找到终止条件**。来看下面的例子

问：假如有n个台阶，每次你可以跨1个或者2个台阶。请问走这n个台阶有多少中走法？

答：先推导一下这个递推公式。如果有n个阶梯，第一步要么走一个阶梯，剩下n-1个阶梯要怎么走；要么走2两个阶梯，剩下n-2个阶梯要走。所以n个阶梯的走法总和等于这两种走法的总和。所以得出递推公式有：`f(n) = f(n-1)+f(n-2)` 。接下来找出终止条件。如果还剩1个阶梯的话，肯定是`f(1) =1`了。如果还剩2两个阶梯，利用公式就是`f(2) = f(1)+f(0)` 。`f(1)=1`的话，`f(0)=1 `零个阶梯，有一种走法，这没意义。所以f(2)也算是一个终止条件，有两种走法，一步一个，一步两个，所以`f(2) = 2`。所以目前的终止条件就是`f(1) =1, f(2) =2`。接下来看看，如果还剩三个阶梯的话，就是`f(3) = f(2)+f(1) = 2+1` 验证满足。总结一下：

**递推公式：**f(n) = f(n-1)+f(n-2)

**终止条件：** f(1) = 1, f(2) = 2

所以递归代码如下

```java
public int f(int n){
    if(n==1) return 1;
    if(n==2) return 2;
    return f(n-1) + f(n-2);
}
```

因此，**编写递归代码关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要尝试用人脑去分解递归的每个步骤**

### 注意点

* 注意调用栈深度过大，导致异常抛出
* 注意重复计算

### 是不是所有的递归都可以不用递归的方式实现呢？

基本上是的。递归本身是利用了系统或者虚拟机提供的函数进栈出栈来实现的。如果我们自己在内存堆上实现栈，手动模拟入栈，出栈的过程。这样任何递归代码都可以改成看上去不是递归的代码的样子