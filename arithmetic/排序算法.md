按时间复杂度分为三类

* O(n2)的，冒泡，插入，选择排序
* O(nlogn) 的，快排，归并排序
* O(n)的，捅，计数，基数排序

### 如何分析一个排序算法

* 排序算法的执行效率

  1. 最好情况，最坏情况，平均情况时间复杂度
  2. 时间复杂度的系数，常数，低阶
  3. 比较次数和交换次数

* 排序算法的内存消耗

  原地排序，是指控件复杂度为o(1)的排序算法

* 排序算法的稳定性

  稳定性，是指待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。比如一组数据 2，9，3，4，8，3，按照大小排序之后就是：2，3，3，4，8，9。这组数据里面有两个伞，经过某种排序之后。如果两个3没有发生顺序变化，则称为稳定的排序算法，否则，则称为不稳定的排序算法。

  其实很多在讲排序的时候，使用的都是整数。但真正开发的时候，我们要排序的都不是整数。列如，订单，有两个属性，时间 和 金额。现有一个需求，根据金额从大到小排序，对于金额相同的订单，根据下单的时间排序。要达到这样的目的，最先想到的应该是，按照金额排序，相同金额，小区间在按照下单时间排序。想起来简单，实现起来可不容易。

  借助稳定的排序算法，可以比较简单实现。我们可以先根据时间进行排序，而后再根据金额进行排序。为什么这样就可以了呢？稳定的排序算法。如果两者相同这不会更新顺序，所以如果我们先按照时间排序，则数据已经是按照时间排序好了。后续，我们只要按照金额进行排序的时候，时间上已经是有序的了。可以查看下面示意图

  ![](https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

### O(n2)的排序算法

#### 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻搞的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它两互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作

![第一次冒泡](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg)

![冒泡次数与结果](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

* 是原地排序算法
* 是稳定的排序算法
* 最好情况的时间复杂度是O(n)进行一次冒泡即可，最坏情况的时间复杂度为O(n2)，数据刚好是倒序的，需要进行n次冒泡。平均时间复杂度，就是加权平均期望时间复杂度，比较复杂。也是O(n2)就是了

#### 插入排序

将数组分为两个区间，已排序区间和未排序区间。初始已排序区间只有数组的第一个元素。取未排序区间中的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束

![插入排序](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

* 插入排序是原地排序算法
* 在插入排序的时候，可以让两个相等的，插入在其后面。所以也是稳定的
* 最好情况的时间复杂度是O(n)进行一次冒泡即可，最坏情况的时间复杂度为O(n2)，数据刚好是倒序的，需要进行n次冒泡。平均时间复杂度，因为在数组中插入一个数据的平均复杂度是O(n)，所以对插入操作都相当于在数组中插入一个数据，循环n次插入操作，所以平均时间复杂为O(n)

#### 选择排序

选择排序和插入排序的算法有些类似，也分已排序区间和未排序区间。但是选择排序每次都从未排序的区间中选出一个最小的元素，将其放到已排序的末尾

![选择排序](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

* 是原地排序算法
* 不是稳定排序算法，比如5，8，5，2，9 使用选择排序的话，第一次找到最小元素是2，与第一个5交换位置，那第一个5和中间的5顺序就变了，所以就不稳定了
* 选择排序的复杂度，最好，最坏，平均情况复杂度都是O(n2)。从n个数据中找出最小的，并循环n次

#### 为什么插入排序比冒泡排序更受欢迎

插入排序和冒泡排序同是稳定排序算法，平均复杂度都是O(n2)。主要是差异是在冒泡排序置换需要三步，而插入排序则只有一步

```java
//冒泡
for (int j = 1; j < length - i; j++) {
    if (a[j] < a[j - 1]) {
        int temp = a[j - 1];
        a[j - 1] = a[j];
        a[j] = temp;
        flag = true;
    }
}
//插入 
for (; j >= 0; --j) {
     if (a[j] > value) {
         a[j + 1] = a[j];
     } else {
         break;
     }
 }
```

